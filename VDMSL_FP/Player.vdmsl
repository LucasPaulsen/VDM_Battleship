module Player
imports from GLOBAL all,
        from Grid all,
        from ArrangingStrategy all,
        from GuessingStrategy all
exports all

definitions

types
Player ::
    Name : seq of char
    Points : nat
    PGrid : Grid`Grid
    guessHist: GLOBAL`GuessHistory
    arngStrat: ArrangingStrategy`ArngType
    guesStrat: GuessingStrategy`GuesType
inv p == p.Points <= GLOBAL`N_SHIPS;


functions 
MakePlayer: seq of char * ArrangingStrategy`ArngType * GuessingStrategy`GuesType -> Player
MakePlayer(s, a, g) == mk_Player(s, 0, [], mk_GLOBAL`GuessHistory([],[]), a, g);

ResetPlayer: Player -> Player
ResetPlayer(p) == MakePlayer(p.Name, p.arngStrat, p.guesStrat);

ArrangeShips: Player -> Player
ArrangeShips(p) == mk_Player(p.Name, p.Points, ArrangingStrategy`Arrange(p.arngStrat), p.guessHist, p.arngStrat, p.guesStrat);

ReceiveGuess: Player * GLOBAL`Coordinates -> Player * GLOBAL`GuessResult
ReceiveGuess(p, c) == let gr = Grid`Hit(p.PGrid, c) in 
    mk_(mk_Player(p.Name, p.Points, gr.#1, p.guessHist, p.arngStrat, p.guesStrat),
        gr.#2);

TakeTurn: Player * Player -> Player * Player
TakeTurn(p1, p2) == (
    let c = GuessingStrategy`Guess(p1.guesStrat, p1.guessHist) in
        let gr = ReceiveGuess(p2, c) in   
            mk_(
                mk_Player(p1.Name, 
                if gr.#2.Sunk then p1.Points + 1 else p1.Points,
                p1.PGrid,
                mk_GLOBAL`GuessHistory([c] ^ p1.guessHist.Coords, [gr.#2] ^ p1.guessHist.Results),
                p1.arngStrat,
                p1.guesStrat),
            gr.#1)
)
post len RESULT.#1.guessHist.Coords = len p1.guessHist.Coords + 1;

end Player